<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Análisis de Datos Categóricos (SOL3070)</title>
    <meta charset="utf-8" />
    <meta name="author" content="  Mauricio Bucca  Profesor Asistente, Sociología UC" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="gentle-r.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Análisis de Datos Categóricos (SOL3070)
## Clase #8
### <br> Mauricio Bucca<br> Profesor Asistente, Sociología UC
### <a href="https://github.com/mebucca">github.com/mebucca</a>

---


class: inverse, center, middle

#Modelos Lineales Generalizados (GLM)

---
## Más allá del modelo de regresión lineal (LM) 

LM es un marco muy útil y productivo, pero hay situaciones en las que no proporciona una descripción adecuada de los datos. En particular:

- Cuando `\(Y\)` no se distribuye normalmente

- Cuando el rango de `\(Y\)` está restringido (por ejemplo, binario, recuento)
 
- Cuando la variación de `\(Y\)` no es independiente de la media de `\(Y\)`.

--

GLM ofrece un marco mucho más general y flexible que incorpora y amplía el LM para abordar estas cuestiones.

---
## Estructura de los modelos lineales generalizados

Un modelo lineal generalizado tiene cuatro componentes:

.pull-left[

- Un _componente aleatorio_

- Un _componente sistemático_ 

- Una _función de enlace_ (link).

- Una _función de varianza_
]

.pull-right[
![nelder](nelder.png)
]

---
### Componente aleatorio

`$$\newcommand{\vect}[1]{\boldsymbol{#1}}$$`

El componente aleatorio de un GLM identifica la distribución de probabilidad de la variable dependiente

  - Al igual que con LM, los datos que queremos modelar ( `\(\vect{y}\)` ) son una colección de observaciones `\(y_{1}, \dots, y_{n}\)`, donde cada observación es la manifestación de una variable aleatoria.
  
  -  Estas variables aleatorias  `\(y_{1}, \dots, y_{n}\)` son independientes  entre si y provienen de la misma _familia_ de distribución: .bold[iid]

    - La distribución de los datos nos da una pista sobre la distribución de probabilidad subyacente
    - Muestreo aleatorio garantiza que spuesto de independencia se cumpla


---
### Componente aleatorio


Mientras que la LM asume que la variable dependiente sigue una distribución normal, GLM puede lidear con un conjunto más amplio de distribuciones, .bold[tanto continuas como discretas], siempre y cuando pertenezcan a la clase más general de la [_familia exponencial de distribuciones_](https://en.wikipedia.org/wiki/Exponential_family).  

--

![Some distributions of the exponential family and their relationship](expo_fam.png)

---
## Componente Sistemático

El componente sistemático de un GLM especifica las variables explicativas, es decir, las `\(x\)`'s en el lado derecho de la ecuación

`$$\eta_{i} = \beta_{0} + \beta_{1} x_{i1} + \dots + \beta_{k} x_{ik}$$`
--

 - En terminología GLM `\(\eta\)` se denomina _predictor lineal_.
 
 - `\(\eta\)` es lineal "en parámetros" pero puede ser no lineal "en variables" (por ejemplo, interacciones, términos cuadrados, etc.). 
 
 - Las `\(x\)`'s son tratadas como fijas, no como variables aleatorias.
 
---
## Función de enlace (link)

En el LM estándar, la media condicional del resultado `\(\mu_{i}\)` está linealmente relacionada con los predictores del modelo.

`$$\underbrace{\mathbb{E}(y_{i} \mid  x_{1}, \dots x_{k} )}_{\mu_{i}} = \underbrace{\beta_{0} + \beta_{1} x_{i1} + \dots + \beta_{k} x_{ik}}_{\eta_{i}}$$`

- GLM permiten una relación más general y flexible entre estos dos términos. 

- En un GLM el componente sistemático debe estar relacionado linealmente (en parámetros) con una función `\(g(\cdot)\)` de la media condicional de `\(y_{i}\)`. Dicha función se denomina *función de enlace*. Formalmente,

`$$g(\mathbb{E}(y_{i} \mid  x_{1}, \dots x_{k})) =  g(\mu_{i}) = \eta_{i}$$`

Ejemplo, si `\(g(\cdot) = \ln(\cdot)\)`, entonces


`$$\ln \mathbb{E}(y_{i} \mid  x_{1}, \dots x_{k}) =  \ln \mu_{i} = \eta_{i}$$`

---

## Función de enlace (link)

- El inverso de esta expresión es la llamada *función media*, que expresa la media condicional de `\(y_{i}\)` como una función potencialmente no lineal de los predictores:

`$$\mathbb{E}(y_{i} \mid  x_{1}, \dots x_{k}) = \mu_{i} = g^{-1}(\eta_{i})$$`
--

Ejemplo, si `\(g(\cdot) = \ln(\cdot)\)`, entonces

`$$\mathbb{E}(y_{i} \mid  x_{1}, \dots x_{k}) = \mu_{i} = e^{\eta_{i}}$$`

- La _función de enlace_ cumple un objetivo importante: mantener `\(\mu_{i}\)` dentro de su rango natural. 

  - Ejemplo: si `\(y_{i}\)` es estrictamente positivo (ingreso), `\(\eta_{i} \in (-\infty, \infty+)\)` pero `\(\mu_{i} = e^{\eta_{i}} \in  (0, \infty+)\)`


---
## Función de enlace (link)

Más allá de este ejemplo, hay una variedad de posibles funciones de enlace:


![Some commonly used link functions](link_fn.png)
---
## Función de varianza

La función de varianza describe cómo la varianza `\(\mathbb{Var}(y_{i})\)` depende de la media `\(\mu_{i}\)`. Formalmente:

&lt;br&gt;

`$$\mathbb{Var}(y_{i}) = \phi V(\mu_{i})$$`
donde

- `\(\phi\)` es una constante llamada "parámetro de dispersión"

- `\(V(\cdot)\)` es una función.


---
## Definiendo un GLM

La estructura básica de un GLM se especifica mediante la elección de la distribución de la variable dependiente (componente sistemático) y la elección de la función de enlace. 


`\begin{align}
  GLM:
	\begin{cases}
	&amp;y_{i} \sim f(\mu_{i},\sigma_{i}) \\ \\
	&amp; g(\mu_{i}) = \eta_{i}
	\end{cases}
\end{align}`

--

Cualquier combinación de estos dos componentes definirá un GLM diferente, lo que dará como resultado un gran número de posibles GLM, cada uno con propiedades particulares. Algunas de estas combinaciones son especialmente relevantes:


| Distribution         | Canonical Link: `\(\eta = g(\mu)\)` | Link name             | Model name           |
| -----------------    | ------------------              | --------------------- | -------------------- |
| Normal (Gaussian)    | `\(\eta = \mu\)`                    | identity              | Standard regression  |
| Poisson              | `\(\eta = \log(\mu)\)`              | logarithm             | Poisson regression   |
| Bernoulli / Binomial | `\(\eta = \log(\mu/(1-\mu))\)`      | logit                 | Logistic regression  |
| Gamma                | `\(\eta = 1/\mu)\)`                 | reciprocal            | Gamma regression     |


---
## LM es un caso particular de GLM

El tipo más simple de GLM es el que tiene un componente aleatorio normal y una función de enlace de identidad, en cuyo caso obtenemos el modelo estándar de regresión lineal. Formalmente:


- `\(y_{1}, \dots y_{n}\)` son `\(n\)` variables independientes con distribución `\(\mathcal{N}(\mu_{i},\sigma)\)`

- `\(\eta_{i}\)` = \beta_{0} + \beta_{1} x_{i1} + \dots + \beta_{k} x_{ik}

- `\(g(x) = x\)`

- `\(\mu_{i} = g(eta_{i}) = \beta_{0} + \beta_{1} x_{i1} + \dots + \beta_{k} x_{ik}\)`


--

Por tanto,


`$$y_{i} \sim \mathcal{N}(\mu_{i} = \eta_{i}, \sigma_{i} = \sigma)$$`

---
## 
Ejemplo:

- `\(y_{1}, \dots y_{n}\)` son `\(n\)` variables independientes con distribución `\(\mathcal{N}(\mu_{i},\sigma)\)`

- `\(\eta_{i}\)` = \beta_{0} + \beta_{1} x_{i1} + \dots + \beta_{k} x_{ik}

- `\(g(\cdot) = \ln(\cdot)\)`, por tanto

- `\(\mu_{i} = \ln(eta_{i}) = \beta_{0} + \beta_{1} x_{i1}, + \dots + \beta_{k} x_{ik}\)`

Obtenemos un _modelo log-lineal_, que es apropiado cuando las predicciones deben ser estrictamente positivas.


`$$\log(\mu_{i}) = \beta_{0} + \beta_{1} x_{i1} + \dots + \beta_{k} x_{ik}$$`

y por tanto, `\(g^{-1}(.) = \exp(.)\)`, liderando la siguiente función media:

`$$\mu_{i} = e^{\beta_{0} + \beta_{1} x_{i1} + \dots + \beta_{k} x_{ik}}$$`
Por tanto,


`$$y_{i} \sim \mathcal{N}(\mu_{i} = e^{\eta_{i}}, \sigma_{i} = \sigma)$$`
---
class: inverse, center, middle

.huge[
**Hasta la próxima clase. Gracias!**
]

&lt;br&gt;
Mauricio Bucca &lt;br&gt;
https://mebucca.github.io/ &lt;br&gt;
github.com/mebucca
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": true,
"slideNumberFormat": "%current%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
